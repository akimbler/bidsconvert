"""Run the BIDSification workflow.

This workflow (1) runs heudiconv to convert dicoms to nifti BIDS format,
(2) defaces anatomical scans, (3) completes relevant metadata in the
dataset, (4) removes extraneous metadata, and (5) cleans up working
directories generated by heudiconv and the workflow.

Parameters
----------
dicomdir : str
    Directory or tar file containing dicom data to be processed
heuristic : str
    Path to heuristic file or name of builtin heudiconv heuristic
subject : str
    Subject ID
session : str or None, optional
    Session ID. Default is None.
output_dir : str, optional
    BIDS dataset directory. Must be either in scratch, the user's home
    directory, or within the current working directory. Default is '.'
    (current working directory).
work_dir : str, optional
    Working directory (in scratch). Default is None, which will generate a
    temporary directory within the output directory.

Warning
-------
When data are located in `/home/data`, this workflow *must* be run from a
parent of the output and data directories. This is because Singularity
cannot mount `/home/data` if it is not in the current path.
"""
import os
import sys
import argparse
import subprocess
from pathlib import Path
import pandas as pd
import numpy as np
from heudiconv.main import workflow as heudiconv
from ..utils.metadata import complete_jsons, clean_metadata
from ..utils.cleanup import clean_tempdirs, update_participants


def run(command, env=None):
    """Run a command with specific environment information.
    
    Parameters
    ----------
    command: command to be sent to system
    env: parameters to be added to environment
    """
    merged_env = os.environ
    if env:
        merged_env.update(env)

    process = subprocess.Popen(
        command,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        shell=True,
        env=merged_env,
    )
    while True:
        line = process.stdout.readline()
        line = line.decode("utf-8")
        sys.stdout.write(line)
        sys.stdout.flush()
        if line == "" and process.poll() is not None:
            break

    if process.returncode != 0:
        raise Exception(
            f"Non zero return code: {process.returncode}\n"
            f"{command}\n\n{process.stdout.read()}"
        )
    return process.returncode


def get_parser():
    """Set up argument parser for scripts."""
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "-d",
        "--dicomdir",
        type=Path,
        required=True,
        dest="dicomdir",
        help="Directory or tar file containing raw data.",
    )
    parser.add_argument(
        "-f",
        "--heuristic",
        type=Path,
        dest="heuristic",
        required=True,
        metavar="HEUR",
        help="Path to a heuristic file or name of a builtin heudiconv heuristic.",
    )
    parser.add_argument(
        "-s",
        "--sub",
        required=True,
        dest="subject",
        help="The label of the subject to analyze.",
    )
    parser.add_argument(
        "-ss",
        "--ses",
        required=False,
        dest="session",
        help="Session identifier",
        default=None,
    )
    parser.add_argument(
        "-o",
        "--output_dir",
        type=Path,
        dest="output_dir",
        required=True,
        metavar="PATH",
        help="BIDS dataset directory. Must be either in "
        "scratch, the user's home directory, or within "
        "the current working directory.",
    )
    parser.add_argument(
        "-w",
        "--work_dir",
        type=Path,
        dest="work_dir",
        required=False,
        metavar="PATH",
        default=None,
        help="Working directory (in scratch).",
    )
    parser.add_argument(
        "--deface-t1", action="store_true", required=False, default=False,
    )
    return parser


def main():
    args = get_parser().parse_args()
    # Heuristic may be file or heudiconv builtin
    # Use existence of file extension to determine if builtin or file
    if not args.heuristic.exists():
        raise ValueError("Heuristic file must be an existing file.")

    temp_dicom_dir = Path(
        args.dicomdir.as_posix().format(subject=args.subject, session=args.session)
    )
    dcm_name = temp_dicom_dir.as_posix()
    if temp_dicom_dir.is_file():
        if not dcm_name.endswith(".gz") or dcm_name.endswith(".tar"):
            raise ValueError("Heudiconv currently only accepts .tar and .tar.gz inputs")
        dir_type = "tarball"
    elif temp_dicom_dir.is_dir() or dcm_name.endswith(".dcm"):
        dir_type = "folder"
    else:
        raise ValueError("dicomdir must be a tarball or directory containing dicoms")
    sub_dir = args.output_dir / f"sub-{args.subject}"
    if args.session:
        sub_dir = args.output_dir / f"sub-{args.subject}/ses-{args.session}"

    args.output_dir.mkdir(parents=True, exist_ok=True)

    if args.work_dir is None:
        work_dir = args.output_dir / ".tmp"
        work_dir = work_dir / args.subject
        if args.session:
            work_dir = work_dir / args.session
    else:
        work_dir = args.work_dir / args.subject
        if args.session:
            work_dir = work_dir / args.session
    work_dir.mkdir(parents=True, exist_ok=True)
    os.environ["TMPDIR"] = str(work_dir.as_posix())
    cwd = os.getcwd()
    os.chdir(work_dir)
    # Run heudiconv
    print(
        args.dicomdir.as_posix(), args.output_dir.as_posix(), args.heuristic.as_posix()
    )
    if dir_type == "tarball":
        heudiconv(
            dicom_dir_template=str(temp_dicom_dir.as_posix())
            .replace(args.subject, "{subject}")
            .replace(args.session, "{session}"),
            subjs=[args.subject],
            session=args.session,
            heuristic=str(args.heuristic.as_posix()),
            converter="dcm2niix",
            outdir=str(args.output_dir.as_posix()),
            bids_options=["all"],
            overwrite=True,
            minmeta=True,
        )
    else:
        heudiconv(
            files=str(args.dicomdir.as_posix()),
            subjs=[args.subject],
            session=args.session,
            heuristic=str(args.heuristic.as_posix()),
            converter="dcm2niix",
            outdir=str(args.output_dir.as_posix()),
            bids_options=["all"],
            overwrite=True,
            minmeta=True,
        )
    bids_files = [
        f
        for f_ in [sub_dir.glob(ext) for ext in ["*/*.nii.gz", "*/*.json", "*/*.tsv"]]
        for f in f_
    ]
    for bids_file in bids_files:
        os.chmod(bids_file, 0o664)

    # Add IntendedFor field to field maps and calculate TotalReadoutTime
    complete_jsons(args.output_dir, args.subject, args.session, overwrite=True)

    # Move "global" metadata keys to top level in jsons
    clean_metadata(args.output_dir, args.subject, args.session)

    # Update participants.tsv with current subject
    update_participants(args.output_dir, temp_dicom_dir, args.subject)

    # Remove temporary subfolders from output directory
    clean_tempdirs(args.output_dir, args.subject, args.session)

    # Run defacer
    if args.deface_t1:
        anat_files = sub_dir.glob("anat/*_T1w.nii.gz")
        for anat in anat_files:
            cmd = (
                f"mri_deface {anat} /src/deface/talairach_mixed_with_skull.gca "
                f"/src/deface/face.gca {anat}"
            )
            run(cmd, env={"TMPDIR": work_dir.name})


if __name__ == "__main__":
    main()
